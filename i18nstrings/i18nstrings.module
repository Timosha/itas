<?php
// $Id$

/**
 * @file
 * Internationalization (i18n) package - translattable strings
 * 
 * @author Jose A. Reyero, 2007
 *
 */

/**
 * Translate configurable string
 */
function tt($context, $string, $langcode = NULL, $update = FALSE) {
  global $language;
  $langcode = $langcode ? $langcode : $language->language;
  
  // If language is default, just return
  if (language_default('language') == $langcode) {
    if ($update) i18nstrings_update_string($context, $string);
    return $string;
  } else {
    return i18nstrings_tt($context, $string, $langcode, $update);
  }
}

/**
 * Translate configurable string
 */
function i18nstrings_tt($context, $string, $langcode, $update = FALSE, $create = TRUE) {
  $context = i18nstrings_context($context);
  
  if ($update) {
    i18nstrings_update_string($context, $string);
  }
  
  $translation = i18nstrings_get_string($context, $langcode);
  
  if ($translation) {
    return ($translation === TRUE) ? $string : $translation;
  } elseif ($translation === FALSE && $create) {
    i18nstrings_update_string($context, $string);
    i18nstrings_cache($context, $string, $langcode, TRUE);
  }
  // Default case, just return untranslated string
  return $string;
}

/**
 * Translate object properties
 */
function i18nstrings_to($context, &$object, $properties = array(), $langcode = NULL, $update = FALSE) {
  $context = i18nstrings_context($context);
  foreach ($properties as $property) {
    $context->property = $property;
    if ($update) {
      tt($context, empty($object->property) ? '' : $object->property , $langcode, TRUE);
    } elseif (!empty($object->$property)) {
      $object->property = tt($context, $object->$property, $langcode);
    }
  }
}

/**
 * Update / create / remove string
 */
function i18nstrings_update_string($context, $string) {
  if ($string) {
    return i18nstrings_add_string($context, $string);
  } else {
    return i18nstrings_remove_string($context);
  }
}

/**
 * Add string
 * 
 * This function checks for already existing string without context for this textgroup
 */
function i18nstrings_add_string($context, $string) {

  $context = i18nstrings_context($context);
  // Check if we have a source string
  $source = i18nstrings_get_source($context, $string);

  $status = SAVED_UPDATED;
  
  if ($source && $source->context) {
    if ($source->source != $string) {
      // String has changed
      db_query("UPDATE {locales_source} SET source = '%s' WHERE lid = %d", $string, $source->lid);
    } else {
      $status = TRUE;
    }
  }
  else {
    if (!$source) {
      db_query("INSERT INTO {locales_source} (location, source, textgroup, version) VALUES ('%s', '%s', '%s', '%s')", request_uri(), $string, $context->textgroup, 0);
      // Clear locale cache so this string can be added in a later request.
      cache_clear_all('locale:'.$context->textgroup.':', 'cache', TRUE);      
      // Create string
      $source->lid = db_last_insert_id('locales_source', 'lid');
      $status = SAVED_NEW; 
    }
    // Store metadata
    db_query("INSERT INTO {i18n_strings} (lid, type, oid, property) VALUES(%d, '%s', %d, '%s')", $source->lid, $context->type, $context->oid, $context->property);
      
  }
  return $status; 
}

/**
 * Remove string
 */

function i18nstrings_get_source($context, $string = NULL) {
  $context = i18nstrings_context($context);
  // Check if we have the string for this context
  if ($source = db_fetch_object(db_query("SELECT s.*, i.type, i.oid, i.property FROM {locales_source} s  INNER JOIN {i18n_strings} i ON s.lid = i.lid WHERE s.textgroup = '%s' AND i.type = '%s' AND i.oid = %d AND i.property = '%s'", $context->textgroup, $context->type, $context->oid, $context->property))) {
    $source->context = $context;
    return $source;
  }
  // Search for the same string for this textgroup without object data
  if ($string && $source = db_fetch_object(db_query("SELECT s.*, i.type, i.oid, i.property FROM {locales_source} s  LEFT JOIN {i18n_strings} i ON s.lid = i.lid WHERE s.textgroup = '%s' AND s.source = '%s' AND i.lid IS NULL", $context->textgroup, $string))) {
    $source->context = NULL;
    return $source;
  }
  return NULL;
}
/**
 * Get string for a language
 * 
 * @return
 *   - translation if found
 *   - TRUE if not found and cached
 *   - FALSE if not even cached
 *
 */
function i18nstrings_get_string($context, $langcode) {
  $context = i18nstrings_context($context);
  if ($translation = i18nstrings_cache($context, $langcode)) {
    return $translation;
  } else {
    // Search translation and add it to the cache
    $text = db_fetch_object(db_query("SELECT s.*, t.translation FROM {locales_source} s  LEFT JOIN {i18n_strings} i ON s.lid = i.lid LEFT JOIN {locales_target} t ON s.lid = t.lid AND t.language = '%s' WHERE s.textgroup = '%s' AND (i.lid IS NULL OR (i.type = '%s' AND i.oid = %d AND i.property = '%s'))", $langcode, $context->textgroup, $context->type, $context->oid, $context->property));
    if ($text && $text->translation) {
      i18nstrings_cache($context, $langcode, NULL, $text->translation);
      return $text->translation;
    } else {
      i18nstrings_cache($context, $langcode, NULL, TRUE);
      return $text ? NULL : FALSE ;
    }
  }   
}

/**
 * Remove string
 */
function i18nstrings_remove_string($context, $string = NULL) {
  if ($source = i18nstrings_get_source($context, $string)) {
    db_query("DELETE FROM {locales_target} WHERE lid = %d", $source->lid);
    db_query("DELETE FROM {i18n_strings} WHERE lid = %d", $source->lid);    
    db_query("DELETE FROM {locales_source} WHERE lid = %d", $source->lid);
    cache_clear_all('locale:'.$context->textgroup.':', 'cache', TRUE);
    return SAVED_DELETED;
  }  
}

/**
 * Provides interface translation services.
 *
 * This function is called from t() to translate a string if needed.
 * 
 * @param $textgroup
 * 
 * @param $string
 *   A string to look up translation for. If omitted, all the
 *   cached strings will be returned in all languages already
 *   used on the page.
 * @param $langcode
 *   Language code to use for the lookup.
 */
function i18nstrings_textgroup($textgroup, $string = NULL, $langcode = NULL) {
  global $language;
  static $locale_t;

  // Return all cached strings if no string was specified
  if (!isset($string)) {
    return isset($locale_t[$textgroup]) ? $locale_t[$textgroup] : array();
  }

  $langcode = isset($langcode) ? $langcode : $language->language;

  // Store database cached translations in a static var.
  if (!isset($locale_t[$langcode])) {
    $locale_t[$langcode] = array();
    // Disabling the usage of string caching allows a module to watch for
    // the exact list of strings used on a page. From a performance
    // perspective that is a really bad idea, so we have no user
    // interface for this. Be careful when turning this option off!
    if (variable_get('locale_cache_strings', 1) == 1) {
      if ($cache = cache_get('locale:'.$textgroup.':'.$langcode, 'cache')) {
        $locale_t[$textgroup][$langcode] = $cache->data;
      }
      else {
        // Refresh database stored cache of translations for given language.
        // We only store short strings used in current version, to improve
        // performance and consume less memory.
        $result = db_query("SELECT s.source, t.translation, t.language FROM {locales_source} s LEFT JOIN {locales_target} t ON s.lid = t.lid AND t.language = '%s' WHERE s.textgroup = '%s' AND s.version = '%s' AND LENGTH(s.source) < 75", $langcode, $textgroup, VERSION);
        while ($data = db_fetch_object($result)) {
          $locale_t[$textgroup][$langcode][$data->source] = (empty($data->translation) ? TRUE : $data->translation);
        }
        cache_set('locale:'.$textgroup.':'. $langcode, $locale_t[$textgroup][$langcode]);
      }
    }
  }

  // If we have the translation cached, skip checking the database
  if (!isset($locale_t[$textgroup][$langcode][$string])) {

    // We do not have this translation cached, so get it from the DB.
    $translation = db_fetch_object(db_query("SELECT s.lid, t.translation, s.version FROM {locales_source} s LEFT JOIN {locales_target} t ON s.lid = t.lid AND t.language = '%s' WHERE s.source = '%s' AND s.textgroup = '%s'", $langcode, $string, $textgroup));
    if ($translation) {
      // We have the source string at least.
      // Cache translation string or TRUE if no translation exists.
      $locale_t[$textgroup][$langcode][$string] = (empty($translation->translation) ? TRUE : $translation->translation);

      if ($translation->version != VERSION) {
        // This is the first use of this string under current Drupal version. Save version
        // and clear cache, to include the string into caching next time. Saved version is
        // also a string-history information for later pruning of the tables.
        db_query("UPDATE {locales_source} SET version = '%s' WHERE lid = %d LIMIT 1", VERSION, $translation->lid);
        cache_clear_all('locale:'.$textgroup.':', 'cache', TRUE);
      }
    }
    else {
      // We don't have the source string, cache this as untranslated.
      db_query("INSERT INTO {locales_source} (location, source, textgroup, version) VALUES ('%s', '%s', 'default', '%s')", request_uri(), $string, VERSION);
      $locale_t[$langcode][$string] = TRUE;
      // Clear locale cache so this string can be added in a later request.
      cache_clear_all('locale:'.$textgroup.':', 'cache', TRUE);
    }
  }

  return ($locale_t[$textgroup][$langcode][$string] === TRUE ? $string : $locale_t[$textgroup][$langcode][$string]);
}

/**
 * Convert context string in a context array
 * 
 * I.e. 
 *   'taxonomy:term:1:name'
 * will become a $context object where
 *   $context->textgroup = 'taxonomy';
 *   $context->type = 'term';
 *   $context->oid = 1;
 *   $context->property = 'name';
 * Examples:
 *  'taxonomy:title' => (taxonomy, title, 0, 0)
 */
function i18nstrings_context($context) {
  // Context may be already an object
  if (is_object($context)) {
    return $context;
  } else {
    list($textgroup, $type, $oid, $property) = split(':', $context);
    return (object)array(
      'textgroup' => $textgroup,
      'type' => $type ? $type : 'string',
      'oid' => $oid ? $oid : 0,
      'property' => $property ? $property : '',
    );
  }
}

/**
 * Prefetch a number of object strings
 */
function i18nstrings_prefetch($context, $langcode = NULL, $join = array(), $conditions = array()) {
  global $language;
  
  $langcode = $langcode ? $langcode : $language->language;
  // Add language condition
  $conditions['t.language'] = $langcode;
  // Get context conditions
  $context = (array)i18nstrings_context($context);
  foreach ($context as $key => $value) {
    if ($value) {
      if ($key == 'textgroup') {
        $conditions['s.textgroup'] = $value;
      } else {
        $conditions['i.'. $key] = $value;
      }
    }
  }
  // Prepare where clause
  $where = $params = array();
  foreach ($conditions as $key => $value) {
    if (is_array($value)) {
      $where[] = $key . ' IN ('.db_placeholders($value, is_int($value[0]) ? 'int' : 'string').')';
      $params = array_merge($params, $value);
    } else {
      $where[] = $key . ' = ' . is_int($value) ? '%d' : "'%s'";
      $params[] = $value;
    }
  }  
  $sql = "SELECT s.textgroup, s.source, i.type, i.oid, i.property, t.translation FROM {locales_source} s  INNER JOIN {i18n_strings} i ON s.lid = i.lid INNER JOIN {locales_target} t ON s.lid = t.lid ";
  $sql .= implode(' ', $join) . ' ' . implode (' AND ', $where);
  $result = db_query($sql, $params);
  
  // Fetch all rows and store in cache
  while ($t = db_fetch_object($result)) {
    i18nstrings_cache($t, $langcode, $t->source, $t->translation);
  }

}

/**
 * Page level cache
 */
function i18nstrings_cache($context, $langcode, $string = NULL, $translation = NULL) {
  static $strings;
  
  $context = i18nstrings_context($context);
  
  // If !$context->type, it will be indexed by string
  if ($translation) {
    if ($context->type) {
      $strings[$langcode][$context->textgroup][$context->type][$context->oid][$context->property] = $translation;
    } else {
      $strings[$langcode][$context->textgroup]['string'][$string] = $translation;
    }
  } else {
    if (!$context->type) {
      return $string && isset($strings[$langcode][$context->textgroup]['string'][$string]) ? $strings[$langcode][$context->textgroup]['string'][$string] : NULL;
    } elseif (!$context->property) {
      // Return the whole object
      return isset($strings[$langcode][$context->textgroup][$context->type][$context->oid]) ? $strings[$langcode][$context->textgroup][$context->type][$context->oid] : NULL;
    } else {
      return isset($strings[$langcode][$context->textgroup][$context->type][$context->oid][$context->property]) ? $strings[$langcode][$context->textgroup][$context->type][$context->oid][$context->property] : NULL;
    }
  }
}

/**
 * Implementation of hook_menu().
 *
function i18nstrings_menu($may_cache) {
  $items = array();
  if ($may_cache) {
    $items[] = array(
      'path' => 'admin/settings/i18n/strings',
      'type' => MENU_LOCAL_TASK,
      'title' => t('Strings'),
      'description' => t('Translatable strings.'),
      'callback' => 'i18nstrings_admin',
       'access' => user_access('administer site configuration'),
      );
  } else {   

  }

  return $items;
}

/**
 * Menu callback. Administration page
 *
function i18nstrings_admin($op = NULL, $strid = NULL) {
  switch($op) {
    case 'edit':
      return drupal_get_form('i18nstrings_admin_form', $strid);
    default:
      return i18nstrings_admin_overview();
  }
}

/**
 * List of strings
 *
function i18nstrings_admin_overview() {
  $output = '';
  $header = array(t('String Id'), t('Default'), '');
  $result = db_query("SELECT DISTINCT(strid) FROM {i18n_strings} ORDER BY strid", i18n_default_language());
  $rows = array();
  while($str = db_fetch_object($result)) {
    $rows[] = array(
      $str->strid, 
      tt($str->strid), 
      l(t('edit'), 'admin/settings/i18n/strings/edit/'.$str->strid)
    );
  }
  $output .= theme('table', $header, $rows);
  return $output;
}

/**
 * Form callback: i18nstrings_admin_form
 *
function i18nstrings_admin_form($strid) {
  $strings = i18nstrings_load($strid);
  $form['strid'] = array('#type' => 'value', '#value' => $strid);
  $form['languages'] = array('#type' => 'fieldset', '#tree' => TRUE, '#title' => t('Translations'));

  // Approximate the number of rows in a textfield with a maximum of 10.
  $default = i18nstrings_get_string($strid, i18n_default_language());
  $rows = min(ceil(str_word_count($default) / 12), 10);
  
  foreach (i18n_supported_languages() as $language => $name) {
    $form['languages'][$language] = array(
      '#type' => 'textarea',
      '#rows' => $rows,
      '#title' => $name,
      '#default_value' => i18nstrings_get_string($strid, $language)
    );
  }
  $form['submit'] = array('#type' => 'submit', '#value' => t('Save'));
  return $form;
}

/**
 * Form submit callback
 *
function i18nstrings_admin_form_submit($form_id, $form_values) {
  $strid = $form_values['strid'];
  foreach (i18n_supported_languages() as $language => $name) {
    i18nstrings_save_string($strid, $language, $form_values['languages'][$language]);
  }
  drupal_set_message(t('The strings have been updated'));
  return 'admin/settings/i18n/strings';
}

/**
 * Load string translations
 *
function i18nstrings_load($strid) {
  $strings = array();
  $result = db_query("SELECT * FROM {i18n_strings} WHERE strid = '%s'", $strid);
  while ($str = db_fetch_object($result)) {
    $strings[$str->locale] = $str->text;
  }
}

/**
 * Save string for a language
 *
function i18nstrings_save_string($strid, $language, $value) {
  drupal_set_message("DEBUG: i18n_strings_save: $strid($language)= $value");
  db_query("DELETE FROM {i18n_strings} WHERE strid = '%s' AND locale = '%s'", $strid, $language);
  db_query("INSERT INTO {i18n_strings}(strid, locale, text) VALUES('%s', '%s', '%s')", $strid, $language, $value);
}
/**/